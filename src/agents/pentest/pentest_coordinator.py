"""
Penetration Testing Coordinator Agent

This agent coordinates all penetration testing activities, manages sub-agents,
and ensures safe and ethical testing practices.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Optional

from langchain_anthropic import ChatAnthropic
from langchain_core.tools import BaseTool

from src.agents.agent_architecture import AgentMemory
from src.memory.memory_persistence import MemoryDatabase
from src.security.safety_controller import SafetyController
from src.security.target_validator import TargetValidator


@dataclass
class PentestTarget:
    """Represents a penetration testing target"""

    target_id: str
    name: str
    ip_addresses: List[str]
    domains: List[str]
    scope: Dict[str, Any]
    authorized: bool = False
    created_at: datetime = None

    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()


@dataclass
class PentestSession:
    """Represents a penetration testing session"""

    session_id: str
    target: PentestTarget
    status: (
        str  # "planning", "reconnaissance", "scanning", "exploitation", "reporting", "completed"
    )
    start_time: datetime
    end_time: Optional[datetime] = None
    findings: List[Dict[str, Any]] = None

    def __post_init__(self):
        if self.findings is None:
            self.findings = []


class PentestCoordinatorAgent:
    """
    Main coordinator for penetration testing operations.

    This agent manages the entire penetration testing lifecycle:
    1. Target validation and authorization
    2. Reconnaissance coordination
    3. Vulnerability scanning oversight
    4. Exploitation management
    5. Reporting and documentation
    """

    def __init__(
        self,
        model: ChatAnthropic,
        tools: List[BaseTool],
        memory: AgentMemory,
        memory_db: MemoryDatabase,
        safety_controller: SafetyController,
        target_validator: TargetValidator,
    ):
        self.model = model
        self.tools = tools
        self.memory = memory
        self.memory_db = memory_db
        self.safety_controller = safety_controller
        self.target_validator = target_validator
        self.logger = logging.getLogger(__name__)

        # Active sessions
        self.active_sessions: Dict[str, PentestSession] = {}

        # Sub-agents (will be initialized later)
        self.recon_agent = None
        self.vuln_scan_agent = None
        self.exploit_agent = None
        self.report_agent = None

    async def initialize_sub_agents(self):
        """Initialize specialized sub-agents"""
        from .exploit_agent import ExploitAgent
        from .recon_agent import ReconAgent
        from .report_agent import ReportAgent
        from .vuln_scan_agent import VulnScanAgent

        self.recon_agent = ReconAgent(self.model, self.tools, self.memory)
        self.vuln_scan_agent = VulnScanAgent(self.model, self.tools, self.memory)
        self.exploit_agent = ExploitAgent(
            self.model, self.tools, self.memory, self.safety_controller
        )
        self.report_agent = ReportAgent(self.model, self.tools, self.memory)

        self.logger.info("Penetration testing sub-agents initialized")

    async def create_pentest_session(
        self,
        target_name: str,
        ip_addresses: List[str],
        domains: List[str],
        scope: Dict[str, Any],
        authorization_token: str,
    ) -> str:
        """
        Create a new penetration testing session

        Args:
            target_name: Name of the target
            ip_addresses: List of target IP addresses
            domains: List of target domains
            scope: Testing scope and limitations
            authorization_token: Authorization token for testing

        Returns:
            Session ID if successful

        Raises:
            ValueError: If target validation fails
            PermissionError: If authorization is invalid
        """
        # Validate target and authorization
        target = PentestTarget(
            target_id=f"target_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            name=target_name,
            ip_addresses=ip_addresses,
            domains=domains,
            scope=scope,
        )

        # Validate authorization
        is_authorized = await self.target_validator.validate_authorization(
            target, authorization_token
        )

        if not is_authorized:
            raise PermissionError("Invalid authorization for penetration testing")

        target.authorized = True

        # Validate target scope
        is_valid_scope = await self.target_validator.validate_scope(target)
        if not is_valid_scope:
            raise ValueError("Target scope validation failed")

        # Create session
        session = PentestSession(
            session_id=f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            target=target,
            status="planning",
            start_time=datetime.now(),
        )

        self.active_sessions[session.session_id] = session

        # Log session creation
        await self.memory_db.store_memory(
            agent_id="pentest_coordinator",
            memory_type="session_created",
            content={
                "session_id": session.session_id,
                "target": target.__dict__,
                "timestamp": datetime.now().isoformat(),
            },
        )

        self.logger.info(f"Created penetration testing session: {session.session_id}")
        return session.session_id

    async def execute_pentest_phase(self, session_id: str, phase: str) -> Dict[str, Any]:
        """
        Execute a specific phase of penetration testing

        Args:
            session_id: Session identifier
            phase: Phase to execute ("reconnaissance", "scanning", "exploitation", "reporting")

        Returns:
            Phase execution results
        """
        if session_id not in self.active_sessions:
            raise ValueError(f"Session {session_id} not found")

        session = self.active_sessions[session_id]

        # Safety check before each phase
        safety_check = await self.safety_controller.pre_phase_check(session, phase)
        if not safety_check.approved:
            raise PermissionError(f"Safety check failed: {safety_check.reason}")

        results = {}

        try:
            if phase == "reconnaissance":
                session.status = "reconnaissance"
                results = await self._execute_reconnaissance(session)

            elif phase == "scanning":
                session.status = "scanning"
                results = await self._execute_vulnerability_scanning(session)

            elif phase == "exploitation":
                session.status = "exploitation"
                results = await self._execute_exploitation(session)

            elif phase == "reporting":
                session.status = "reporting"
                results = await self._execute_reporting(session)
                session.status = "completed"
                session.end_time = datetime.now()

            else:
                raise ValueError(f"Unknown phase: {phase}")

            # Store phase results
            await self.memory_db.store_memory(
                agent_id="pentest_coordinator",
                memory_type=f"phase_{phase}",
                content={
                    "session_id": session_id,
                    "phase": phase,
                    "results": results,
                    "timestamp": datetime.now().isoformat(),
                },
            )

            return results

        except Exception as e:
            self.logger.error(f"Error in phase {phase}: {str(e)}")
            # Emergency stop if needed
            await self.safety_controller.emergency_stop(session_id, str(e))
            raise

    async def _execute_reconnaissance(self, session: PentestSession) -> Dict[str, Any]:
        """Execute reconnaissance phase"""
        if not self.recon_agent:
            await self.initialize_sub_agents()

        return await self.recon_agent.perform_reconnaissance(session.target)

    async def _execute_vulnerability_scanning(self, session: PentestSession) -> Dict[str, Any]:
        """Execute vulnerability scanning phase"""
        if not self.vuln_scan_agent:
            await self.initialize_sub_agents()

        return await self.vuln_scan_agent.perform_vulnerability_scan(session.target)

    async def _execute_exploitation(self, session: PentestSession) -> Dict[str, Any]:
        """Execute exploitation phase"""
        if not self.exploit_agent:
            await self.initialize_sub_agents()

        return await self.exploit_agent.perform_exploitation(session.target, session.findings)

    async def _execute_reporting(self, session: PentestSession) -> Dict[str, Any]:
        """Execute reporting phase"""
        if not self.report_agent:
            await self.initialize_sub_agents()

        return await self.report_agent.generate_report(session)

    async def get_session_status(self, session_id: str) -> Dict[str, Any]:
        """Get current status of a penetration testing session"""
        if session_id not in self.active_sessions:
            raise ValueError(f"Session {session_id} not found")

        session = self.active_sessions[session_id]
        return {
            "session_id": session_id,
            "status": session.status,
            "target": session.target.__dict__,
            "start_time": session.start_time.isoformat(),
            "end_time": session.end_time.isoformat() if session.end_time else None,
            "findings_count": len(session.findings),
        }

    async def emergency_stop(self, session_id: str, reason: str = "Manual stop"):
        """Emergency stop for a penetration testing session"""
        if session_id in self.active_sessions:
            session = self.active_sessions[session_id]
            session.status = "stopped"
            session.end_time = datetime.now()

            await self.safety_controller.emergency_stop(session_id, reason)

            self.logger.warning(f"Emergency stop for session {session_id}: {reason}")
