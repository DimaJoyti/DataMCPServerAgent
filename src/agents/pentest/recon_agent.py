"""
Reconnaissance Agent for Penetration Testing

This agent performs OSINT (Open Source Intelligence) gathering using various tools
including Bright Data integration for advanced web scraping and data collection.
"""

import asyncio
import logging
import socket
import whois
from typing import Dict, List, Any, Optional
from datetime import datetime
from dataclasses import dataclass

from langchain_anthropic import ChatAnthropic
from langchain_core.tools import BaseTool
import dns.resolver
import requests

from src.agents.agent_architecture import AgentMemory
from src.tools.pentest_tools.osint_tools import OSINTToolkit
from src.tools.bright_data_tools import BrightDataToolkit

@dataclass
class ReconResult:
    """Represents reconnaissance results"""
    target_info: Dict[str, Any]
    dns_info: Dict[str, Any]
    whois_info: Dict[str, Any]
    subdomain_info: List[str]
    social_media_info: Dict[str, Any]
    technology_stack: List[str]
    potential_vulnerabilities: List[str]
    timestamp: datetime

class ReconAgent:
    """
    Reconnaissance Agent for OSINT gathering

    This agent performs comprehensive reconnaissance including:
    1. DNS enumeration
    2. WHOIS lookups
    3. Subdomain discovery
    4. Technology fingerprinting
    5. Social media intelligence
    6. Dark web monitoring (via Bright Data)
    """

    def __init__(
        self,
        model: ChatAnthropic,
        tools: List[BaseTool],
        memory: AgentMemory,
        bright_data_session=None
    ):
        self.model = model
        self.tools = tools
        self.memory = memory
        self.bright_data_session = bright_data_session
        self.logger = logging.getLogger(__name__)

        # Initialize toolkits
        self.osint_toolkit = OSINTToolkit()
        if bright_data_session:
            self.bright_data_toolkit = BrightDataToolkit(bright_data_session)

    async def perform_reconnaissance(self, target) -> Dict[str, Any]:
        """
        Perform comprehensive reconnaissance on target

        Args:
            target: PentestTarget object

        Returns:
            Comprehensive reconnaissance results
        """
        self.logger.info(f"Starting reconnaissance for target: {target.name}")

        recon_tasks = []

        # DNS reconnaissance
        for domain in target.domains:
            recon_tasks.append(self._dns_reconnaissance(domain))

        # WHOIS reconnaissance
        for domain in target.domains:
            recon_tasks.append(self._whois_reconnaissance(domain))

        # Subdomain discovery
        for domain in target.domains:
            recon_tasks.append(self._subdomain_discovery(domain))

        # Technology fingerprinting
        for domain in target.domains:
            recon_tasks.append(self._technology_fingerprinting(domain))

        # Social media intelligence
        recon_tasks.append(self._social_media_intelligence(target.name))

        # Execute all reconnaissance tasks
        results = await asyncio.gather(*recon_tasks, return_exceptions=True)

        # Compile results
        compiled_results = {
            "target_id": target.target_id,
            "target_name": target.name,
            "dns_results": [],
            "whois_results": [],
            "subdomains": [],
            "technologies": [],
            "social_media": {},
            "potential_vulnerabilities": [],
            "timestamp": datetime.now().isoformat()
        }

        # Process results
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                self.logger.error(f"Reconnaissance task {i} failed: {str(result)}")
                continue

            if isinstance(result, dict):
                if "dns_info" in result:
                    compiled_results["dns_results"].append(result)
                elif "whois_info" in result:
                    compiled_results["whois_results"].append(result)
                elif "subdomains" in result:
                    compiled_results["subdomains"].extend(result["subdomains"])
                elif "technologies" in result:
                    compiled_results["technologies"].extend(result["technologies"])
                elif "social_media" in result:
                    compiled_results["social_media"].update(result["social_media"])

        # Analyze results for potential vulnerabilities
        compiled_results["potential_vulnerabilities"] = await self._analyze_vulnerabilities(compiled_results)

        self.logger.info(f"Reconnaissance completed for target: {target.name}")
        return compiled_results

    async def _dns_reconnaissance(self, domain: str) -> Dict[str, Any]:
        """Perform DNS reconnaissance"""
        dns_info = {
            "domain": domain,
            "dns_info": {},
            "timestamp": datetime.now().isoformat()
        }

        try:
            # A records
            try:
                a_records = dns.resolver.resolve(domain, 'A')
                dns_info["dns_info"]["A"] = [str(record) for record in a_records]
            except Exception as e:
                dns_info["dns_info"]["A"] = []

            # AAAA records
            try:
                aaaa_records = dns.resolver.resolve(domain, 'AAAA')
                dns_info["dns_info"]["AAAA"] = [str(record) for record in aaaa_records]
            except Exception as e:
                dns_info["dns_info"]["AAAA"] = []

            # MX records
            try:
                mx_records = dns.resolver.resolve(domain, 'MX')
                dns_info["dns_info"]["MX"] = [str(record) for record in mx_records]
            except Exception as e:
                dns_info["dns_info"]["MX"] = []

            # NS records
            try:
                ns_records = dns.resolver.resolve(domain, 'NS')
                dns_info["dns_info"]["NS"] = [str(record) for record in ns_records]
            except Exception as e:
                dns_info["dns_info"]["NS"] = []

            # TXT records
            try:
                txt_records = dns.resolver.resolve(domain, 'TXT')
                dns_info["dns_info"]["TXT"] = [str(record) for record in txt_records]
            except Exception as e:
                dns_info["dns_info"]["TXT"] = []

        except Exception as e:
            self.logger.error(f"DNS reconnaissance failed for {domain}: {str(e)}")
            dns_info["error"] = str(e)

        return dns_info

    async def _whois_reconnaissance(self, domain: str) -> Dict[str, Any]:
        """Perform WHOIS reconnaissance"""
        whois_info = {
            "domain": domain,
            "whois_info": {},
            "timestamp": datetime.now().isoformat()
        }

        try:
            w = whois.whois(domain)
            whois_info["whois_info"] = {
                "registrar": w.registrar,
                "creation_date": str(w.creation_date) if w.creation_date else None,
                "expiration_date": str(w.expiration_date) if w.expiration_date else None,
                "name_servers": w.name_servers if w.name_servers else [],
                "status": w.status if w.status else [],
                "emails": w.emails if w.emails else [],
                "org": w.org if hasattr(w, 'org') else None,
                "country": w.country if hasattr(w, 'country') else None
            }
        except Exception as e:
            self.logger.error(f"WHOIS reconnaissance failed for {domain}: {str(e)}")
            whois_info["error"] = str(e)

        return whois_info

    async def _subdomain_discovery(self, domain: str) -> Dict[str, Any]:
        """Discover subdomains using various techniques"""
        subdomain_info = {
            "domain": domain,
            "subdomains": [],
            "timestamp": datetime.now().isoformat()
        }

        # Common subdomain list
        common_subdomains = [
            "www", "mail", "ftp", "admin", "test", "dev", "staging", "api",
            "blog", "shop", "store", "support", "help", "docs", "portal",
            "secure", "vpn", "remote", "login", "dashboard", "panel"
        ]

        discovered_subdomains = []

        for subdomain in common_subdomains:
            full_domain = f"{subdomain}.{domain}"
            try:
                # Try to resolve the subdomain
                socket.gethostbyname(full_domain)
                discovered_subdomains.append(full_domain)
            except socket.gaierror:
                # Subdomain doesn't exist
                pass
            except Exception as e:
                self.logger.debug(f"Error checking subdomain {full_domain}: {str(e)}")

        subdomain_info["subdomains"] = discovered_subdomains

        # If Bright Data is available, use it for advanced subdomain discovery
        if self.bright_data_toolkit:
            try:
                advanced_subdomains = await self._bright_data_subdomain_discovery(domain)
                subdomain_info["subdomains"].extend(advanced_subdomains)
                # Remove duplicates
                subdomain_info["subdomains"] = list(set(subdomain_info["subdomains"]))
            except Exception as e:
                self.logger.error(f"Bright Data subdomain discovery failed: {str(e)}")

        return subdomain_info

    async def _technology_fingerprinting(self, domain: str) -> Dict[str, Any]:
        """Fingerprint technologies used by the target"""
        tech_info = {
            "domain": domain,
            "technologies": [],
            "timestamp": datetime.now().isoformat()
        }

        try:
            # Make HTTP request to analyze headers and content
            url = f"https://{domain}"
            response = requests.get(url, timeout=10, verify=False)

            technologies = []

            # Analyze HTTP headers
            headers = response.headers

            if 'Server' in headers:
                technologies.append(f"Server: {headers['Server']}")

            if 'X-Powered-By' in headers:
                technologies.append(f"X-Powered-By: {headers['X-Powered-By']}")

            if 'X-Generator' in headers:
                technologies.append(f"Generator: {headers['X-Generator']}")

            # Analyze content for technology indicators
            content = response.text.lower()

            # Common CMS detection
            if 'wp-content' in content or 'wordpress' in content:
                technologies.append("WordPress")

            if 'drupal' in content:
                technologies.append("Drupal")

            if 'joomla' in content:
                technologies.append("Joomla")

            # JavaScript frameworks
            if 'react' in content:
                technologies.append("React")

            if 'angular' in content:
                technologies.append("Angular")

            if 'vue' in content:
                technologies.append("Vue.js")

            # Web servers
            if 'apache' in headers.get('Server', '').lower():
                technologies.append("Apache")

            if 'nginx' in headers.get('Server', '').lower():
                technologies.append("Nginx")

            if 'iis' in headers.get('Server', '').lower():
                technologies.append("IIS")

            tech_info["technologies"] = technologies

        except Exception as e:
            self.logger.error(f"Technology fingerprinting failed for {domain}: {str(e)}")
            tech_info["error"] = str(e)

        return tech_info

    async def _social_media_intelligence(self, target_name: str) -> Dict[str, Any]:
        """Gather social media intelligence"""
        social_info = {
            "target_name": target_name,
            "social_media": {},
            "timestamp": datetime.now().isoformat()
        }

        # If Bright Data is available, use it for social media scraping
        if self.bright_data_toolkit:
            try:
                social_data = await self._bright_data_social_intelligence(target_name)
                social_info["social_media"] = social_data
            except Exception as e:
                self.logger.error(f"Social media intelligence failed: {str(e)}")
                social_info["error"] = str(e)

        return social_info

    async def _bright_data_subdomain_discovery(self, domain: str) -> List[str]:
        """Use Bright Data for advanced subdomain discovery"""
        # This would use Bright Data's advanced scraping capabilities
        # to discover subdomains from various sources
        subdomains = []

        try:
            # Use Bright Data to scrape subdomain databases
            # This is a placeholder - actual implementation would use Bright Data API
            search_query = f"site:{domain}"
            # results = await self.bright_data_toolkit.search_subdomains(search_query)
            # subdomains = self._extract_subdomains_from_results(results)
        except Exception as e:
            self.logger.error(f"Bright Data subdomain discovery error: {str(e)}")

        return subdomains

    async def _bright_data_social_intelligence(self, target_name: str) -> Dict[str, Any]:
        """Use Bright Data for social media intelligence gathering"""
        social_data = {}

        try:
            # Use Bright Data to scrape social media platforms
            # This is a placeholder - actual implementation would use Bright Data API
            # social_data = await self.bright_data_toolkit.gather_social_intelligence(target_name)
            pass
        except Exception as e:
            self.logger.error(f"Bright Data social intelligence error: {str(e)}")

        return social_data

    async def _analyze_vulnerabilities(self, recon_results: Dict[str, Any]) -> List[str]:
        """Analyze reconnaissance results for potential vulnerabilities"""
        vulnerabilities = []

        # Analyze DNS results
        for dns_result in recon_results.get("dns_results", []):
            dns_info = dns_result.get("dns_info", {})

            # Check for wildcard DNS
            if len(dns_info.get("A", [])) > 10:
                vulnerabilities.append("Potential wildcard DNS configuration")

            # Check for SPF records
            txt_records = dns_info.get("TXT", [])
            has_spf = any("spf" in record.lower() for record in txt_records)
            if not has_spf:
                vulnerabilities.append("Missing SPF record - potential email spoofing vulnerability")

        # Analyze technology stack
        technologies = recon_results.get("technologies", [])
        for tech in technologies:
            if "wordpress" in tech.lower():
                vulnerabilities.append("WordPress detected - check for outdated plugins/themes")
            if "apache" in tech.lower():
                vulnerabilities.append("Apache server detected - check for version vulnerabilities")
            if "php" in tech.lower():
                vulnerabilities.append("PHP detected - check for version vulnerabilities")

        # Analyze subdomains
        subdomains = recon_results.get("subdomains", [])
        for subdomain in subdomains:
            if "test" in subdomain or "dev" in subdomain or "staging" in subdomain:
                vulnerabilities.append(f"Development/testing subdomain found: {subdomain}")

        return vulnerabilities
