"""
Penetration Testing Main Entry Point for DataMCPServerAgent

This module provides the main entry point for penetration testing operations,
integrating LLM capabilities with security tools and Bright Data OSINT.
"""

import asyncio
import logging
import os
from typing import Dict, List, Any, Optional
from datetime import datetime

from dotenv import load_dotenv
from langchain_anthropic import ChatAnthropic
from langchain_core.tools import BaseTool
from langchain_mcp_adapters.tools import load_mcp_tools
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

from src.agents.pentest.pentest_coordinator import PentestCoordinatorAgent
from src.agents.agent_architecture import AgentMemory
from src.memory.memory_persistence import MemoryDatabase
from src.tools.bright_data_tools import BrightDataToolkit
from src.tools.pentest_tools.nmap_tools import NmapToolkit
from src.security.safety_controller import SafetyController, SafetyLevel
from src.security.target_validator import TargetValidator
from src.security.command_filter import CommandFilter
from src.security.audit_logger import AuditLogger
from src.security.resource_monitor import ResourceMonitor
from src.utils.error_handlers import format_error_for_user

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('pentest_operations.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)


async def create_pentest_system() -> PentestCoordinatorAgent:
    """
    Create and initialize the penetration testing system
    
    Returns:
        Configured PentestCoordinatorAgent
    """
    logger.info("Initializing penetration testing system...")
    
    # Initialize LLM model
    model = ChatAnthropic(
        model="claude-3-sonnet-20240229",
        temperature=0.1,  # Low temperature for consistent security operations
        max_tokens=4000
    )
    
    # Initialize memory systems
    memory = AgentMemory()
    memory_db = MemoryDatabase()
    
    # Initialize security components
    safety_controller = SafetyController(
        safety_level=SafetyLevel.HIGH  # High safety level for pentest operations
    )
    target_validator = TargetValidator()
    command_filter = CommandFilter()
    audit_logger = AuditLogger()
    resource_monitor = ResourceMonitor()
    
    # Initialize Bright Data MCP connection
    bright_data_session = None
    bright_data_tools = []
    
    try:
        # Connect to Bright Data MCP server
        server_params = StdioServerParameters(
            command="npx",
            args=["-y", "@brightdata/mcp-server-bright-data"],
            env={
                "BRIGHT_DATA_API_TOKEN": os.getenv("BRIGHT_DATA_API_TOKEN", ""),
                **os.environ
            }
        )
        
        bright_data_session = await stdio_client(server_params)
        
        # Load Bright Data tools
        bright_data_tools = await load_mcp_tools(bright_data_session)
        logger.info(f"Loaded {len(bright_data_tools)} Bright Data tools")
        
        # Create enhanced Bright Data toolkit
        bright_data_toolkit = BrightDataToolkit(bright_data_session)
        enhanced_tools = await bright_data_toolkit.create_custom_tools()
        osint_tools = await bright_data_toolkit.create_osint_tools()
        
        bright_data_tools.extend(enhanced_tools)
        bright_data_tools.extend(osint_tools)
        
    except Exception as e:
        logger.warning(f"Failed to initialize Bright Data MCP: {str(e)}")
        logger.info("Continuing without Bright Data integration")
    
    # Initialize Nmap toolkit
    nmap_toolkit = NmapToolkit(safety_controller)
    nmap_tools = await nmap_toolkit.create_nmap_tools()
    
    # Combine all tools
    all_tools = bright_data_tools + nmap_tools
    
    logger.info(f"Initialized {len(all_tools)} total tools for penetration testing")
    
    # Create penetration testing coordinator
    pentest_coordinator = PentestCoordinatorAgent(
        model=model,
        tools=all_tools,
        memory=memory,
        memory_db=memory_db,
        safety_controller=safety_controller,
        target_validator=target_validator
    )
    
    # Initialize sub-agents
    await pentest_coordinator.initialize_sub_agents()
    
    logger.info("Penetration testing system initialized successfully")
    return pentest_coordinator


async def run_pentest_session():
    """Run an interactive penetration testing session"""
    print("ðŸ”’ DataMCPServerAgent Penetration Testing System")
    print("=" * 60)
    print("âš ï¸  WARNING: This system is for authorized penetration testing only!")
    print("   Ensure you have proper authorization before testing any targets.")
    print("=" * 60)
    
    try:
        # Initialize the penetration testing system
        pentest_coordinator = await create_pentest_system()
        
        while True:
            print("\nðŸŽ¯ Penetration Testing Menu:")
            print("1. Create new penetration testing session")
            print("2. View active sessions")
            print("3. Execute reconnaissance phase")
            print("4. Execute vulnerability scanning phase")
            print("5. Execute exploitation phase (CAUTION)")
            print("6. Generate penetration testing report")
            print("7. Emergency stop all operations")
            print("8. Exit")
            
            choice = input("\nSelect an option (1-8): ").strip()
            
            if choice == "1":
                await create_new_session(pentest_coordinator)
            elif choice == "2":
                await view_active_sessions(pentest_coordinator)
            elif choice == "3":
                await execute_reconnaissance(pentest_coordinator)
            elif choice == "4":
                await execute_vulnerability_scanning(pentest_coordinator)
            elif choice == "5":
                await execute_exploitation(pentest_coordinator)
            elif choice == "6":
                await generate_report(pentest_coordinator)
            elif choice == "7":
                await emergency_stop(pentest_coordinator)
            elif choice == "8":
                print("ðŸ‘‹ Exiting penetration testing system...")
                break
            else:
                print("âŒ Invalid option. Please select 1-8.")
                
    except KeyboardInterrupt:
        print("\n\nðŸ›‘ Operation interrupted by user")
    except Exception as e:
        logger.error(f"Error in penetration testing session: {str(e)}")
        print(f"âŒ Error: {format_error_for_user(e)}")


async def create_new_session(coordinator: PentestCoordinatorAgent):
    """Create a new penetration testing session"""
    print("\nðŸ“‹ Creating New Penetration Testing Session")
    print("-" * 50)
    
    try:
        # Get target information
        target_name = input("Target name/organization: ").strip()
        if not target_name:
            print("âŒ Target name is required")
            return
        
        # Get IP addresses
        ip_input = input("Target IP addresses (comma-separated): ").strip()
        ip_addresses = [ip.strip() for ip in ip_input.split(",") if ip.strip()]
        
        # Get domains
        domain_input = input("Target domains (comma-separated): ").strip()
        domains = [domain.strip() for domain in domain_input.split(",") if domain.strip()]
        
        if not ip_addresses and not domains:
            print("âŒ At least one IP address or domain is required")
            return
        
        # Get scope information
        print("\nDefine testing scope:")
        scope_description = input("Scope description: ").strip()
        excluded_ips = input("Excluded IP addresses (comma-separated): ").strip()
        excluded_domains = input("Excluded domains (comma-separated): ").strip()
        
        scope = {
            "description": scope_description,
            "excluded_ips": [ip.strip() for ip in excluded_ips.split(",") if ip.strip()],
            "excluded_domains": [domain.strip() for domain in excluded_domains.split(",") if domain.strip()],
            "testing_window": {
                "start": datetime.now().isoformat(),
                "duration_hours": 24  # Default 24-hour window
            }
        }
        
        # Get authorization
        print("\nâš ï¸  AUTHORIZATION REQUIRED")
        print("You must have explicit written authorization to test these targets.")
        auth_confirmation = input("Do you have written authorization? (yes/no): ").strip().lower()
        
        if auth_confirmation != "yes":
            print("âŒ Written authorization is required for penetration testing")
            return
        
        auth_token = input("Authorization token/reference: ").strip()
        if not auth_token:
            print("âŒ Authorization token is required")
            return
        
        # Create the session
        print("\nðŸ”„ Creating penetration testing session...")
        session_id = await coordinator.create_pentest_session(
            target_name=target_name,
            ip_addresses=ip_addresses,
            domains=domains,
            scope=scope,
            authorization_token=auth_token
        )
        
        print(f"âœ… Session created successfully!")
        print(f"ðŸ“‹ Session ID: {session_id}")
        print(f"ðŸŽ¯ Target: {target_name}")
        print(f"ðŸŒ IPs: {', '.join(ip_addresses)}")
        print(f"ðŸ”— Domains: {', '.join(domains)}")
        
    except Exception as e:
        logger.error(f"Error creating session: {str(e)}")
        print(f"âŒ Failed to create session: {format_error_for_user(e)}")


async def view_active_sessions(coordinator: PentestCoordinatorAgent):
    """View active penetration testing sessions"""
    print("\nðŸ“Š Active Penetration Testing Sessions")
    print("-" * 50)
    
    try:
        if not coordinator.active_sessions:
            print("No active sessions found.")
            return
        
        for session_id, session in coordinator.active_sessions.items():
            print(f"\nðŸ” Session: {session_id}")
            print(f"   Target: {session.target.name}")
            print(f"   Status: {session.status}")
            print(f"   Started: {session.start_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"   Findings: {len(session.findings)}")
            
            if session.end_time:
                print(f"   Ended: {session.end_time.strftime('%Y-%m-%d %H:%M:%S')}")
                
    except Exception as e:
        logger.error(f"Error viewing sessions: {str(e)}")
        print(f"âŒ Error viewing sessions: {format_error_for_user(e)}")


async def execute_reconnaissance(coordinator: PentestCoordinatorAgent):
    """Execute reconnaissance phase"""
    print("\nðŸ” Execute Reconnaissance Phase")
    print("-" * 40)
    
    try:
        if not coordinator.active_sessions:
            print("âŒ No active sessions. Create a session first.")
            return
        
        # Select session
        session_id = await select_session(coordinator)
        if not session_id:
            return
        
        print(f"\nðŸ”„ Starting reconnaissance for session {session_id}...")
        results = await coordinator.execute_pentest_phase(session_id, "reconnaissance")
        
        print("âœ… Reconnaissance completed!")
        print("\nðŸ“Š Results Summary:")
        print(f"   DNS Records: {len(results.get('dns_results', []))}")
        print(f"   Subdomains: {len(results.get('subdomains', []))}")
        print(f"   Technologies: {len(results.get('technologies', []))}")
        print(f"   Vulnerabilities: {len(results.get('potential_vulnerabilities', []))}")
        
    except Exception as e:
        logger.error(f"Error in reconnaissance: {str(e)}")
        print(f"âŒ Reconnaissance failed: {format_error_for_user(e)}")


async def select_session(coordinator: PentestCoordinatorAgent) -> Optional[str]:
    """Helper function to select an active session"""
    if len(coordinator.active_sessions) == 1:
        return list(coordinator.active_sessions.keys())[0]
    
    print("\nSelect a session:")
    sessions = list(coordinator.active_sessions.items())
    for i, (session_id, session) in enumerate(sessions, 1):
        print(f"{i}. {session_id} - {session.target.name} ({session.status})")
    
    try:
        choice = int(input("Enter session number: ").strip())
        if 1 <= choice <= len(sessions):
            return sessions[choice - 1][0]
        else:
            print("âŒ Invalid session number")
            return None
    except ValueError:
        print("âŒ Invalid input")
        return None


async def execute_vulnerability_scanning(coordinator: PentestCoordinatorAgent):
    """Execute vulnerability scanning phase"""
    print("\nðŸ” Execute Vulnerability Scanning Phase")
    print("-" * 45)
    
    try:
        if not coordinator.active_sessions:
            print("âŒ No active sessions. Create a session first.")
            return
        
        session_id = await select_session(coordinator)
        if not session_id:
            return
        
        print(f"\nðŸ”„ Starting vulnerability scanning for session {session_id}...")
        results = await coordinator.execute_pentest_phase(session_id, "scanning")
        
        print("âœ… Vulnerability scanning completed!")
        print("\nðŸ“Š Results Summary:")
        print(f"   Hosts scanned: {len(results.get('hosts', []))}")
        print(f"   Open ports: {results.get('total_open_ports', 0)}")
        print(f"   Services detected: {results.get('total_services', 0)}")
        
    except Exception as e:
        logger.error(f"Error in vulnerability scanning: {str(e)}")
        print(f"âŒ Vulnerability scanning failed: {format_error_for_user(e)}")


async def execute_exploitation(coordinator: PentestCoordinatorAgent):
    """Execute exploitation phase with extra safety checks"""
    print("\nâš ï¸  Execute Exploitation Phase")
    print("-" * 35)
    print("ðŸš¨ WARNING: This phase will attempt to exploit vulnerabilities!")
    print("   Only proceed if you have explicit authorization.")
    
    confirmation = input("\nType 'AUTHORIZED' to proceed: ").strip()
    if confirmation != "AUTHORIZED":
        print("âŒ Exploitation cancelled")
        return
    
    try:
        if not coordinator.active_sessions:
            print("âŒ No active sessions. Create a session first.")
            return
        
        session_id = await select_session(coordinator)
        if not session_id:
            return
        
        print(f"\nðŸ”„ Starting exploitation for session {session_id}...")
        results = await coordinator.execute_pentest_phase(session_id, "exploitation")
        
        print("âœ… Exploitation phase completed!")
        print("\nðŸ“Š Results Summary:")
        print(f"   Exploitation attempts: {results.get('attempts', 0)}")
        print(f"   Successful exploits: {results.get('successful', 0)}")
        print(f"   Access gained: {results.get('access_gained', 'None')}")
        
    except Exception as e:
        logger.error(f"Error in exploitation: {str(e)}")
        print(f"âŒ Exploitation failed: {format_error_for_user(e)}")


async def generate_report(coordinator: PentestCoordinatorAgent):
    """Generate penetration testing report"""
    print("\nðŸ“„ Generate Penetration Testing Report")
    print("-" * 45)
    
    try:
        if not coordinator.active_sessions:
            print("âŒ No active sessions. Create a session first.")
            return
        
        session_id = await select_session(coordinator)
        if not session_id:
            return
        
        print(f"\nðŸ”„ Generating report for session {session_id}...")
        results = await coordinator.execute_pentest_phase(session_id, "reporting")
        
        print("âœ… Report generated successfully!")
        print(f"\nðŸ“„ Report saved to: {results.get('report_path', 'Unknown')}")
        print(f"ðŸ“Š Executive summary: {results.get('executive_summary', 'Not available')}")
        
    except Exception as e:
        logger.error(f"Error generating report: {str(e)}")
        print(f"âŒ Report generation failed: {format_error_for_user(e)}")


async def emergency_stop(coordinator: PentestCoordinatorAgent):
    """Emergency stop all operations"""
    print("\nðŸ›‘ Emergency Stop")
    print("-" * 20)
    
    confirmation = input("Are you sure you want to stop all operations? (yes/no): ").strip().lower()
    if confirmation == "yes":
        await coordinator.emergency_stop("manual", "User initiated emergency stop")
        print("âœ… All operations stopped")
    else:
        print("âŒ Emergency stop cancelled")


if __name__ == "__main__":
    asyncio.run(run_pentest_session())
